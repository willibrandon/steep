// Node Initialization gRPC Service Definitions
// Extends steep.repl.v1 with initialization operations

syntax = "proto3";

package steep.repl.v1;

option go_package = "steep/internal/repl/grpc/proto";

import "google/protobuf/timestamp.proto";

// =============================================================================
// Initialization Service
// =============================================================================

service InitService {
    // Start automatic snapshot initialization
    rpc StartInit(StartInitRequest) returns (StartInitResponse);

    // Prepare for manual initialization (creates slot, returns LSN)
    rpc PrepareInit(PrepareInitRequest) returns (PrepareInitResponse);

    // Complete manual initialization
    rpc CompleteInit(CompleteInitRequest) returns (CompleteInitResponse);

    // Cancel in-progress initialization
    rpc CancelInit(CancelInitRequest) returns (CancelInitResponse);

    // Get current initialization progress
    rpc GetProgress(GetProgressRequest) returns (GetProgressResponse);

    // Stream real-time progress updates
    rpc StreamProgress(StreamProgressRequest) returns (stream ProgressUpdate);

    // Start reinitialization
    rpc StartReinit(StartReinitRequest) returns (StartReinitResponse);

    // Compare schemas between nodes
    rpc CompareSchemas(CompareSchemasRequest) returns (CompareSchemasResponse);

    // Get schema fingerprints from this node's database
    rpc GetSchemaFingerprints(GetSchemaFingerprintsRequest) returns (GetSchemaFingerprintsResponse);

    // Get column-level differences for a specific table
    rpc GetColumnDiff(GetColumnDiffRequest) returns (GetColumnDiffResponse);

    // Capture fingerprints for tables in the local database
    rpc CaptureFingerprints(CaptureFingerprintsRequest) returns (CaptureFingerprintsResponse);

    // Generate snapshot (two-phase, phase 1)
    rpc GenerateSnapshot(GenerateSnapshotRequest) returns (stream SnapshotProgress);

    // Apply snapshot (two-phase, phase 2)
    rpc ApplySnapshot(ApplySnapshotRequest) returns (stream SnapshotProgress);

    // Start bidirectional merge initialization
    rpc StartBidirectionalMerge(StartBidirectionalMergeRequest) returns (StartBidirectionalMergeResponse);
}

// =============================================================================
// Enums
// =============================================================================

enum InitState {
    INIT_STATE_UNSPECIFIED = 0;
    INIT_STATE_UNINITIALIZED = 1;
    INIT_STATE_PREPARING = 2;
    INIT_STATE_COPYING = 3;
    INIT_STATE_CATCHING_UP = 4;
    INIT_STATE_SYNCHRONIZED = 5;
    INIT_STATE_DIVERGED = 6;
    INIT_STATE_FAILED = 7;
    INIT_STATE_REINITIALIZING = 8;
}

enum InitMethod {
    INIT_METHOD_UNSPECIFIED = 0;
    INIT_METHOD_SNAPSHOT = 1;      // Automatic via copy_data=true
    INIT_METHOD_MANUAL = 2;        // User-provided backup
    INIT_METHOD_TWO_PHASE = 3;     // Generate then apply
    INIT_METHOD_DIRECT = 4;        // Combined two-phase (smaller DBs)
    INIT_METHOD_BIDIRECTIONAL_MERGE = 5;  // Merge existing data, then enable replication
}

enum ConflictStrategy {
    CONFLICT_STRATEGY_UNSPECIFIED = 0;
    CONFLICT_STRATEGY_PREFER_NODE_A = 1;  // Keep local values
    CONFLICT_STRATEGY_PREFER_NODE_B = 2;  // Keep remote values
    CONFLICT_STRATEGY_LAST_MODIFIED = 3;  // Keep most recently modified
    CONFLICT_STRATEGY_MANUAL = 4;         // Log conflicts for manual resolution
}

enum SchemaSyncMode {
    SCHEMA_SYNC_UNSPECIFIED = 0;
    SCHEMA_SYNC_STRICT = 1;        // Fail on mismatch
    SCHEMA_SYNC_AUTO = 2;          // Apply DDL to fix
    SCHEMA_SYNC_MANUAL = 3;        // Warn only
}

enum ComparisonStatus {
    COMPARISON_STATUS_UNSPECIFIED = 0;
    COMPARISON_STATUS_MATCH = 1;
    COMPARISON_STATUS_MISMATCH = 2;
    COMPARISON_STATUS_LOCAL_ONLY = 3;
    COMPARISON_STATUS_REMOTE_ONLY = 4;
}

// =============================================================================
// Start Initialization
// =============================================================================

message StartInitRequest {
    string target_node_id = 1;
    string source_node_id = 2;
    InitMethod method = 3;
    InitOptions options = 4;
    // Source node connection info - auto-registers source if not already known
    SourceNodeInfo source_node_info = 5;
}

// Connection info for the source node (for auto-registration)
message SourceNodeInfo {
    string host = 1;
    int32 port = 2;
    string database = 3;
    string user = 4;
    // Password should come from PGPASSWORD env var, not proto
}

message InitOptions {
    int32 parallel_workers = 1;
    SchemaSyncMode schema_sync_mode = 2;
    bool force = 3;                    // Truncate existing data if present
    string large_table_method = 4;     // pg_dump, copy, basebackup
    int64 large_table_threshold = 5;   // Bytes
}

message StartInitResponse {
    bool success = 1;
    string error = 2;
    InitState state = 3;
}

// =============================================================================
// Prepare/Complete Manual Init
// =============================================================================

message PrepareInitRequest {
    string node_id = 1;
    string slot_name = 2;
}

message PrepareInitResponse {
    bool success = 1;
    string error = 2;
    string slot_name = 3;
    string lsn = 4;
    google.protobuf.Timestamp created_at = 5;
}

message CompleteInitRequest {
    string target_node_id = 1;
    string source_node_id = 2;
    string source_lsn = 3;
    SchemaSyncMode schema_sync_mode = 4;
    SourceNodeInfo source_node_info = 5;  // Required for subscription connection
    bool skip_schema_check = 6;
    string source_remote = 7;             // gRPC address of source daemon for schema verification
}

message CompleteInitResponse {
    bool success = 1;
    string error = 2;
    InitState state = 3;
    repeated SchemaComparison schema_mismatches = 4;
}

// =============================================================================
// Cancel Initialization
// =============================================================================

message CancelInitRequest {
    string node_id = 1;
    bool cleanup_partial = 2;         // Truncate partially copied tables
}

message CancelInitResponse {
    bool success = 1;
    string error = 2;
    InitState previous_state = 3;
}

// =============================================================================
// Progress Tracking
// =============================================================================

message GetProgressRequest {
    string node_id = 1;
}

message GetProgressResponse {
    bool has_progress = 1;
    InitProgress progress = 2;
}

message StreamProgressRequest {
    string node_id = 1;
    int32 interval_ms = 2;            // Update interval (default 1000)
}

message ProgressUpdate {
    InitProgress progress = 1;
    google.protobuf.Timestamp timestamp = 2;
}

message InitProgress {
    string node_id = 1;
    InitState state = 2;
    string phase = 3;                  // generation, application, catching_up
    float overall_percent = 4;
    int32 tables_total = 5;
    int32 tables_completed = 6;
    string current_table = 7;
    float current_table_percent = 8;
    int64 rows_copied = 9;
    int64 bytes_copied = 10;
    float throughput_rows_sec = 11;
    google.protobuf.Timestamp started_at = 12;
    int32 eta_seconds = 13;
    int32 parallel_workers = 14;
    string error_message = 15;
    repeated TableProgress completed_tables = 16;
    repeated string pending_tables = 17;
}

message TableProgress {
    string schema = 1;
    string table = 2;
    int64 rows = 3;
    int64 bytes = 4;
    int32 duration_ms = 5;
}

// =============================================================================
// Reinitialization
// =============================================================================

message StartReinitRequest {
    string node_id = 1;
    ReinitScope scope = 2;
}

message ReinitScope {
    oneof scope {
        bool full = 1;                 // Full node reinit
        TableList tables = 2;          // Specific tables
        string schema = 3;             // Entire schema
    }
}

message TableList {
    repeated string tables = 1;        // Format: schema.table
}

message StartReinitResponse {
    bool success = 1;
    string error = 2;
    InitState state = 3;
    int32 tables_affected = 4;
}

// =============================================================================
// Schema Comparison
// =============================================================================

message CompareSchemasRequest {
    string local_node_id = 1;
    string remote_node_id = 2;
    repeated string schemas = 3;       // Empty = all schemas
}

message CompareSchemasResponse {
    bool success = 1;
    string error = 2;
    repeated SchemaComparison comparisons = 3;
    int32 match_count = 4;
    int32 mismatch_count = 5;
    int32 local_only_count = 6;
    int32 remote_only_count = 7;
}

message SchemaComparison {
    string table_schema = 1;
    string table_name = 2;
    string local_fingerprint = 3;
    string remote_fingerprint = 4;
    ComparisonStatus status = 5;
    repeated ColumnDifference differences = 6;
}

message ColumnDifference {
    string column_name = 1;
    string difference_type = 2;        // missing, extra, type_change, default_change
    string local_definition = 3;
    string remote_definition = 4;
}

// =============================================================================
// Schema Fingerprints (for remote schema verification)
// =============================================================================

message GetSchemaFingerprintsRequest {
    repeated string schemas = 1;       // Empty = public schema only
}

message GetSchemaFingerprintsResponse {
    bool success = 1;
    string error = 2;
    repeated TableFingerprint fingerprints = 3;
}

message TableFingerprint {
    string schema_name = 1;
    string table_name = 2;
    string fingerprint = 3;            // SHA256 hash of column definitions
    string column_definitions = 4;     // JSON array of column info for diff display
}

// =============================================================================
// Column Diff (for detailed schema comparison)
// =============================================================================

message GetColumnDiffRequest {
    string peer_node_id = 1;            // Remote node to compare against
    string table_schema = 2;            // Schema name (e.g., "public")
    string table_name = 3;              // Table name (e.g., "users")
}

message GetColumnDiffResponse {
    bool success = 1;
    string error = 2;
    repeated ColumnDifference differences = 3;
}

// =============================================================================
// Capture Fingerprints
// =============================================================================

message CaptureFingerprintsRequest {
    string node_id = 1;                 // Node ID to associate fingerprints with
    repeated string schemas = 2;        // Schemas to capture (empty = all)
}

message CaptureFingerprintsResponse {
    bool success = 1;
    string error = 2;
    int32 table_count = 3;              // Number of tables fingerprinted
    repeated TableFingerprint fingerprints = 4;  // Captured fingerprints
}

// =============================================================================
// Two-Phase Snapshot
// =============================================================================

message GenerateSnapshotRequest {
    string source_node_id = 1;
    string output_path = 2;
    int32 parallel_workers = 3;
    string compression = 4;            // none, gzip, lz4, zstd
}

message ApplySnapshotRequest {
    string target_node_id = 1;
    string input_path = 2;
    string source_node_id = 3;         // For subscription creation
    int32 parallel_workers = 4;
    bool verify_checksums = 5;
}

message SnapshotProgress {
    string snapshot_id = 1;
    string phase = 2;                  // schema, data, sequences, subscription
    float overall_percent = 3;
    string current_table = 4;
    float current_table_percent = 5;
    int64 bytes_processed = 6;
    float throughput_mb_sec = 7;
    int32 eta_seconds = 8;
    string lsn = 9;                    // Captured/applied LSN
    bool complete = 10;
    string error = 11;
}

// =============================================================================
// Bidirectional Merge Initialization
// =============================================================================

message StartBidirectionalMergeRequest {
    string node_a_id = 1;              // Local node ID
    string node_b_id = 2;              // Remote node ID
    string node_b_conn_str = 3;        // Connection string for remote node
    repeated string tables = 4;        // Tables to merge (schema.table format)
    ConflictStrategy strategy = 5;     // Conflict resolution strategy
    bool dry_run = 6;                  // Preview without applying changes
    SchemaSyncMode schema_sync = 7;    // Schema sync mode
    int32 quiesce_timeout_ms = 8;      // Timeout for quiescing writes (default 5000)
}

message StartBidirectionalMergeResponse {
    bool success = 1;
    string error = 2;
    BidirectionalMergeResult result = 3;
}

message BidirectionalMergeResult {
    int64 tables_processed = 1;
    int64 conflicts_detected = 2;
    int64 conflicts_resolved = 3;
    int64 rows_transferred_a_to_b = 4;
    int64 rows_transferred_b_to_a = 5;
    bool replication_setup = 6;
    string slot_a_to_b = 7;           // Replication slot name A -> B
    string slot_b_to_a = 8;           // Replication slot name B -> A
    repeated TableMergeResult table_results = 9;
}

message TableMergeResult {
    string schema = 1;
    string table = 2;
    int64 rows_a_only = 3;            // Rows only in node A (copied to B)
    int64 rows_b_only = 4;            // Rows only in node B (copied to A)
    int64 rows_conflict = 5;          // Rows with conflicting values
    int64 rows_identical = 6;         // Rows identical on both nodes
    string resolution = 7;            // How conflicts were resolved
}
